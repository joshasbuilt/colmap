<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floorplan Coordinates - Rectangle View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
        }
        
        #canvas {
            display: block;
        }
        
        /* Context Menu */
        #context-menu {
            position: fixed;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 0;
            display: none;
            z-index: 10000;
            min-width: 180px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .context-menu-item {
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .context-menu-item:hover {
            background: rgba(0, 150, 255, 0.3);
        }
        
        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        
        .context-menu-separator {
            height: 1px;
            background: #444;
            margin: 4px 0;
        }
        
        /* Image Strip Panel */
        .image-strip-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 200px;
            height: 100vh;
            background: rgba(20, 20, 20, 0.95);
            border-left: 2px solid #444;
            z-index: 6000;
            display: flex;
            flex-direction: column;
        }
        
        .image-strip-header {
            padding: 15px;
            background: rgba(40, 40, 40, 0.9);
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sort-select {
            background: rgba(60, 60, 60, 0.9);
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .sort-select:focus {
            outline: none;
            border-color: #0f0;
        }
        
        .image-strip-header h3 {
            color: white;
            font-size: 16px;
            margin: 0;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            background: rgba(255, 0, 0, 0.3);
            border-radius: 3px;
        }
        
        .image-strip-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .image-thumbnail {
            width: 100%;
            margin-bottom: 10px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        
        .image-thumbnail:hover {
            border-color: #0f0;
        }
        
        .image-thumbnail img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 2px;
        }
        
         .image-thumbnail .frame-number {
             position: absolute;
             bottom: 2px;
             left: 2px;
             background: rgba(0, 0, 0, 0.7);
             color: white;
             padding: 2px 6px;
             font-size: 11px;
             border-radius: 2px;
         }
         
         .image-thumbnail .remove-btn {
             position: absolute;
             top: 2px;
             right: 2px;
             background: rgba(255, 0, 0, 0.8);
             color: white;
             border: none;
             border-radius: 50%;
             width: 20px;
             height: 20px;
             font-size: 12px;
             font-weight: bold;
             cursor: pointer;
             display: flex;
             align-items: center;
             justify-content: center;
             opacity: 0;
             transition: opacity 0.2s;
         }
         
         .image-thumbnail:hover .remove-btn {
             opacity: 1;
         }
         
         .image-thumbnail .remove-btn:hover {
             background: rgba(255, 0, 0, 1);
             transform: scale(1.1);
         }
        
        .image-thumbnail {
            position: relative;
        }
        
        /* Image preview overlay */
        .image-preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 7000;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        
        .image-preview-overlay img {
            max-width: 80vw;
            max-height: 80vh;
            border: 2px solid #0f0;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        /* Info Panel */
        #info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 5000;
            min-width: 300px;
        }
        
        .info-row {
            margin: 5px 0;
        }
        
        .info-label {
            display: inline-block;
            width: 100px;
            color: #999;
        }
        
        .info-value {
            color: #0f0;
            font-family: monospace;
        }
        
        .info-separator {
            height: 1px;
            background: #333;
            margin: 10px 0;
        }
        
        /* Cursor Coordinates Display */
        #cursor-coords {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            border-radius: 5px;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-item" data-action="lock">Lock</div>
        <div class="context-menu-item" data-action="unlock">Unlock</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="bring-forward">Bring Forward</div>
        <div class="context-menu-item" data-action="send-backward">Send Backward</div>
        <div class="context-menu-item" data-action="bring-to-front">Bring to Front</div>
        <div class="context-menu-item" data-action="send-to-back">Send to Back</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="show-images">Show Images</div>
        <div class="context-menu-item" data-action="remove-range">Remove 0203-0209</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="delete">Delete</div>
    </div>
    
    <!-- Image Strip Panel -->
    <div id="image-strip-panel" class="image-strip-panel" style="display: none;">
        <div class="image-strip-header">
            <div class="header-controls">
                <select id="sort-order" class="sort-select">
                    <option value="asc">Frame ↑</option>
                    <option value="desc">Frame ↓</option>
                </select>
                <button id="close-image-strip" class="close-btn">&times;</button>
            </div>
        </div>
        <div id="image-strip-content" class="image-strip-content">
            <!-- Thumbnails will be loaded here -->
        </div>
    </div>
    
    <!-- Image Preview Overlay -->
    <div id="image-preview-overlay" class="image-preview-overlay" style="display: none;">
        <img id="preview-image" src="" alt="Preview">
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div class="info-row">
            <span class="info-label">Zoom:</span>
            <span class="info-value" id="zoom-value">100%</span>
        </div>
        <div class="info-row">
            <span class="info-label">Pan:</span>
            <span class="info-value" id="pan-value">(0, 0)</span>
        </div>
        <div class="info-separator"></div>
        <div class="info-row">
            <span class="info-label">Selected:</span>
            <span class="info-value" id="selected-value">None</span>
        </div>
        <div class="info-row">
            <span class="info-label">Position:</span>
            <span class="info-value" id="position-value">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Scale:</span>
            <span class="info-value" id="scale-value">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Rotation:</span>
            <span class="info-value" id="rotation-value">-</span>
        </div>
        <div class="info-separator"></div>
        <div class="info-row">
            <span class="info-label">Locked:</span>
            <span class="info-value" id="locked-value">-</span>
        </div>
        <div class="info-separator"></div>
        <div class="info-row">
            <span class="info-label">Mode:</span>
            <span class="info-value" id="mode-value">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Resources:</span>
            <span class="info-value" id="resource-value">-</span>
        </div>
    </div>

        <!-- Cursor Coordinates Display -->
        <div id="cursor-coords">
            <div>N: <span id="cursor-northing">-</span></div>
            <div>E: <span id="cursor-easting">-</span></div>
        </div>
    

    <script>
        /*
         * AsBuiltVault Configuration System
         * 
         * This project uses a single configuration flag to switch between local development 
         * and AsBuiltVault production resource loading:
         * 
         * Key Configuration:
         * window.runningFromDevelopersLocal = false - This single flag controls everything
         * 
         * When false (production): Resources load from https://vaultprojectswebprod.z8.web.core.windows.net
         * When true (local dev): Resources load from local files
         * 
         * AsBuiltVault URL Structure:
         * Base URL: https://vaultprojectswebprod.z8.web.core.windows.net
         * Path prefix: /aframe-vr/aligncolmap
         * Full URL: https://vaultprojectswebprod.z8.web.core.windows.net/aframe-vr/aligncolmap/
         * 
         * How it works:
         * The system dynamically loads resources based on this flag
         * Production mode fetches images, SVGs, and other assets from AsBuiltVault storage
         * Local development mode serves files from the local file system
         * This allows seamless switching between development and production environments with a single toggle
         */
        
        // AsBuiltVault Configuration
        window.runningFromDevelopersLocal = true; // Set to true for local development
        
        // Resource loading configuration
        const config = {
            baseUrl: window.runningFromDevelopersLocal ? '' : 'https://vaultprojectswebprod.z8.web.core.windows.net',
            pathPrefix: '/aframe-vr/aligncolmap',
            getResourceUrl: function(resourcePath) {
                if (window.runningFromDevelopersLocal) {
                    return resourcePath; // Local file
                } else {
                    return this.baseUrl + this.pathPrefix + '/' + resourcePath;
                }
            }
        };
        
        // State for panning
        let isPanning = false;
        let lastPosX = 0;
        let lastPosY = 0;
        let contextMenuTarget = null;
        
        // Catch middle mouse at document level (before Fabric can interfere)
        document.addEventListener('mousedown', function(evt) {
            if (evt.button === 1) { // Middle mouse
                isPanning = true;
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
                evt.preventDefault();
                evt.stopPropagation();
            } else if (evt.button === 2) { // Right mouse
                evt.preventDefault();
                evt.stopPropagation();
                
                // Check if we're over an object
                const target = window.canvas.findTarget(evt, false);
                
                if (target) {
                    contextMenuTarget = target;
                    window.canvas.setActiveObject(target);
                    showContextMenu(evt.clientX, evt.clientY, target);
                } else {
                    hideContextMenu();
                }
            }
        }, true);
        
        document.addEventListener('mousemove', function(evt) {
            if (isPanning && window.canvas) {
                const deltaX = evt.clientX - lastPosX;
                const deltaY = evt.clientY - lastPosY;
                
                // Update viewport transform
                const vpt = window.canvas.viewportTransform;
                vpt[4] += deltaX;
                vpt[5] += deltaY;
                window.canvas.requestRenderAll();
                
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
                updateInfoPanel();
                evt.preventDefault();
            }
        }, true);
        
        document.addEventListener('mouseup', function(evt) {
            if (evt.button === 1 && isPanning) {
                isPanning = false;
                evt.preventDefault();
            }
        }, true);
        
        // Prevent browser's default context menu everywhere
        document.addEventListener('contextmenu', function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
        }, true);
        
        // Hide context menu on click
        document.addEventListener('click', () => {
            hideContextMenu();
        });
        
        // Close image strip panel
        document.getElementById('close-image-strip').addEventListener('click', () => {
            hideImageStrip();
        });
        
        // Sort order change handler
        document.getElementById('sort-order').addEventListener('change', (e) => {
            if (currentImageFilenames.length > 0) {
                displayImagesWithSort(e.target.value);
            }
        });
        
         // Global mouse up handler to hide preview when mouse is released anywhere
         document.addEventListener('mouseup', (e) => {
             // Only hide preview if it's currently showing
             const overlay = document.getElementById('image-preview-overlay');
             if (overlay.style.display === 'flex') {
                 hideImagePreview();
             }
         });

        // Function to list all objects on canvas (for debugging)
        function listAllObjects() {
            console.log('=== ALL OBJECTS ON CANVAS ===');
            canvas.getObjects().forEach((obj, index) => {
                console.log(`${index}: ${obj.customName || 'unnamed'} (${obj.type})`);
            });
        }
        
        // Make it available globally for console debugging
        window.listAllObjects = listAllObjects;
        
        // Function to extract images from any SVG by name (for testing)
        function extractImagesFromSVGByName(svgName) {
            const svgObject = canvas.getObjects().find(obj => obj.customName === svgName);
            if (svgObject) {
                console.log('Found SVG:', svgName);
                extractImageFilenamesFromSVG(svgObject);
            } else {
                console.log('SVG not found:', svgName);
                console.log('Available SVGs:');
                canvas.getObjects().forEach(obj => {
                    if (obj.customName && obj.customName.includes('Camera Positions')) {
                        console.log('- ' + obj.customName);
                    }
                });
            }
        }
        
        // Make it available globally for console debugging
        window.extractImagesFromSVGByName = extractImagesFromSVGByName;
        
        // Function to map camera image filename to preview image filename
        function mapCameraToPreviewFilename(cameraFilename) {
            // Extract frame number from camera filename
            // Example: "pano_camera1/frame_0414_hp_preview.jpg" -> "0414"
            const frameMatch = cameraFilename.match(/frame_(\d+)_hp_preview\.jpg/);
            if (frameMatch) {
                const frameNumber = frameMatch[1];
                return `hp_preview image/frame_${frameNumber}.jpg`;
            }
            return null;
        }
        
        // Global variable to store current image filenames for re-sorting
        let currentImageFilenames = [];
        
        // Function to show image strip panel
        function showImageStrip(imageFilenames) {
            const panel = document.getElementById('image-strip-panel');
            const content = document.getElementById('image-strip-content');
            
            // Store filenames globally for re-sorting
            currentImageFilenames = [...imageFilenames];
            
            // Clear existing content
            content.innerHTML = '';
            
            // Get current sort order
            const sortOrder = document.getElementById('sort-order').value;
            
            // Sort and display images
            displayImagesWithSort(sortOrder);
            
            // Show the panel
            panel.style.display = 'flex';
        }
        
        // Function to display images with specified sort order
        function displayImagesWithSort(sortOrder) {
            const content = document.getElementById('image-strip-content');
            
            // Clear existing content
            content.innerHTML = '';
            
            // Sort filenames by frame number
            const sortedFilenames = [...currentImageFilenames].sort((a, b) => {
                const frameA = a.match(/frame_(\d+)/);
                const frameB = b.match(/frame_(\d+)/);
                if (frameA && frameB) {
                    const frameNumA = parseInt(frameA[1]);
                    const frameNumB = parseInt(frameB[1]);
                    return sortOrder === 'desc' ? frameNumB - frameNumA : frameNumA - frameNumB;
                }
                return a.localeCompare(b);
            });
            
            // Create thumbnails for each image
            sortedFilenames.forEach(filename => {
                const frameMatch = filename.match(/frame_(\d+)/);
                const previewFilename = mapCameraToPreviewFilename(filename);
                if (previewFilename) {
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'image-thumbnail';
                    thumbnail.dataset.frameNumber = frameMatch ? frameMatch[1] : 'unknown';
                    
                    const img = document.createElement('img');
                    img.src = previewFilename;
                    img.alt = filename;
                    
                     const frameNumber = document.createElement('div');
                     frameNumber.className = 'frame-number';
                     const frameNum = frameMatch ? frameMatch[1] : '?';
                     frameNumber.textContent = frameNum;
                     
                     // Create remove button
                     const removeBtn = document.createElement('button');
                     removeBtn.className = 'remove-btn';
                     removeBtn.textContent = '×';
                     removeBtn.title = `Remove frame ${frameNum}`;
                     
                     // Add click event to remove button
                     removeBtn.addEventListener('click', (e) => {
                         e.preventDefault();
                         e.stopPropagation();
                         if (frameMatch) {
                             removeSingleCameraPosition(frameMatch[1]);
                         }
                     });
                     
                      // Add mouse event listeners for preview
                      thumbnail.addEventListener('mousedown', (e) => {
                          e.preventDefault();
                          showImagePreview(previewFilename);
                          
                          // Highlight the specific dot - ONLY when thumbnail is clicked
                          if (frameMatch) {
                              highlightThumbnailDot(frameMatch[1]);
                          }
                      });
                      
                      thumbnail.addEventListener('mouseup', (e) => {
                          e.preventDefault();
                          hideImagePreview();
                      });
                      
                      thumbnail.addEventListener('mouseleave', (e) => {
                          hideImagePreview();
                      });
                     
                     // Prevent context menu on thumbnails
                     thumbnail.addEventListener('contextmenu', (e) => {
                         e.preventDefault();
                     });
                     
                     thumbnail.appendChild(img);
                     thumbnail.appendChild(frameNumber);
                     thumbnail.appendChild(removeBtn);
                     content.appendChild(thumbnail);
                }
            });
        }
        
        // Function to hide image strip panel
        function hideImageStrip() {
            document.getElementById('image-strip-panel').style.display = 'none';
        }
        
        // Function to remove a single thumbnail from the image strip (efficient)
        function removeThumbnailFromStrip(frameNumber) {
            const content = document.getElementById('image-strip-content');
            const thumbnail = content.querySelector(`[data-frame-number="${frameNumber}"]`);
            if (thumbnail) {
                thumbnail.remove();
                console.log(`Removed thumbnail for frame ${frameNumber} from image strip`);
            }
        }
        
         // Function to show image preview
         function showImagePreview(imageSrc) {
             const overlay = document.getElementById('image-preview-overlay');
             const previewImg = document.getElementById('preview-image');
             previewImg.src = imageSrc;
             overlay.style.display = 'flex';
         }
         
         // Function to hide image preview
         function hideImagePreview() {
             document.getElementById('image-preview-overlay').style.display = 'none';
         }
         
        // Function to highlight a specific dot when thumbnail is clicked
        function highlightThumbnailDot(frameNumber) {
            const activeObject = canvas.getActiveObject();
            if (!activeObject || !activeObject.customName || !activeObject.customName.includes('Camera Positions')) {
                console.log('No camera positions SVG selected');
                return;
            }

            const group = activeObject;
            const objects = group._objects || group.objects;

            // First, clear any existing highlights to ensure only one dot is highlighted
            clearThumbnailHighlights();

            // Find and highlight ONLY the specific circle - change appearance only
            let found = false;
            objects.forEach((obj, index) => {
                if (obj.type === 'circle' && obj.title) {
                    const frameMatch = obj.title.match(/frame_(\d+)/);
                    
                        if (frameMatch && frameMatch[1] === frameNumber) {
                            // Extract camera info from title for display
                            const titleParts = obj.title.split(' | ');
                            const cameraInfo = titleParts[0]; // "Camera 84"
                            const coords2D = titleParts[1]; // "2D: (4.94, -3.19)"
                            const coords3D = titleParts[2]; // "3D: (3.15, 1.13, 1.18)"
                            const imageName = titleParts[3]; // "Image: pano_camera1/frame_0121_hp_preview.jpg"
                            const frameInfo = titleParts[4]; // "Frame: 3458"
                            const heightInfo = titleParts[5]; // "Height: 1.18m"
                            
                            // Get the circle's actual position on the canvas (accounting for group transform)
                            const group = activeObject;
                            const groupLeft = group.left || 0;
                            const groupTop = group.top || 0;
                            const groupScaleX = group.scaleX || 1;
                            const groupScaleY = group.scaleY || 1;
                            
                            // Calculate the circle's absolute position on canvas
                            const circleCanvasX = groupLeft + (obj.left * groupScaleX);
                            const circleCanvasY = groupTop + (obj.top * groupScaleY);
                            
                            // Convert to Mt Eden coordinates using the actual canvas position
                            const mtEdenCoords = canvasToMtEden(circleCanvasX, circleCanvasY, mtEdenBounds, canvas.width, canvas.height);
                            
                            console.log('🎯 SELECTED CAMERA:', {
                                camera: cameraInfo,
                                frame: frameNumber,
                                coords2D: coords2D,
                                coords3D: coords3D,
                                image: imageName.replace('Image: ', ''),
                                frameId: frameInfo.replace('Frame: ', ''),
                                height: heightInfo.replace('Height: ', '')
                            });
                            console.log('📍 COORDINATES:');
                            console.log(`   Easting: E: ${mtEdenCoords.x.toFixed(3)}`);
                            console.log(`   Northing: N: ${mtEdenCoords.y.toFixed(3)}`);
                        
                        // Only change appearance properties, don't touch position or size
                        obj.set('fill', 'green');
                        obj.set('stroke', 'darkgreen');
                        obj.set('strokeWidth', 0.1);
                        found = true;
                    }
                }
            });
             
            if (!found) {
                console.log('❌ No matching circle found for frame:', frameNumber);
            }
             
            canvas.requestRenderAll();
        }
         
         
        // Function to clear highlights - ONLY called from thumbnail interactions
        function clearThumbnailHighlights() {
            const activeObject = canvas.getActiveObject();
            
            if (!activeObject || !activeObject.customName || !activeObject.customName.includes('Camera Positions')) {
                return;
            }
            
            const group = activeObject;
            const objects = group._objects || group.objects;
            
            // Reset all circles to red
            objects.forEach((obj) => {
                if (obj.type === 'circle') {
                    obj.set('fill', 'red');
                    obj.set('stroke', 'darkred');
                    obj.set('strokeWidth', 0.0246); // Reset to original small stroke width
                }
            });
            
            canvas.requestRenderAll();
        }
         
         // Function to remove a single camera position from the current SVG group
         function removeSingleCameraPosition(frameNumber) {
             // Find the currently selected SVG group
             const activeObject = canvas.getActiveObject();
             if (!activeObject || !activeObject.customName || !activeObject.customName.includes('Camera Positions')) {
                 console.log('No camera positions SVG selected');
                 return;
             }
             
             const group = activeObject;
             const objects = group._objects || group.objects;
             
             // Find the circle with the matching frame number
             let circleToRemove = null;
             let circleIndex = -1;
             
             objects.forEach((obj, index) => {
                 if (obj.type === 'circle' && obj.title) {
                     const frameMatch = obj.title.match(/frame_(\d+)/);
                     if (frameMatch && frameMatch[1] === frameNumber) {
                         circleToRemove = obj;
                         circleIndex = index;
                     }
                 }
             });
             
             if (!circleToRemove) {
                 console.log(`Camera position with frame ${frameNumber} not found`);
                 return;
             }
             
             console.log(`Removing single camera position: frame ${frameNumber}`);
             
             // Remove all polylines first
             const polylineIndices = [];
             objects.forEach((obj, index) => {
                 if (obj.type === 'polyline') {
                     polylineIndices.push(index);
                 }
             });
             
             polylineIndices.sort((a, b) => b - a).forEach(index => {
                 const obj = objects[index];
                 group.removeWithUpdate(obj);
             });
             
             // Remove the specific circle
             group.removeWithUpdate(circleToRemove);
             
             // Recreate polylines for remaining camera positions
             const remainingObjects = group._objects || group.objects;
             const remainingCircles = remainingObjects.filter(obj => obj.type === 'circle');
             
             if (remainingCircles.length > 1) {
                 // Sort remaining circles by frame number
                 const sortedCircles = remainingCircles.sort((a, b) => {
                     const frameA = a.title ? a.title.match(/frame_(\d+)/) : null;
                     const frameB = b.title ? b.title.match(/frame_(\d+)/) : null;
                     
                     if (frameA && frameB) {
                         return parseInt(frameA[1]) - parseInt(frameB[1]);
                     }
                     return 0;
                 });
                 
                 // Get positions of remaining circles
                 const groupLeft = group.left || 0;
                 const groupTop = group.top || 0;
                 
                 const points = sortedCircles.map(circle => ({
                     x: (circle.left || 0) + groupLeft,
                     y: (circle.top || 0) + groupTop
                 }));
                 
                 // Create new polyline
                 const newPolyline = new fabric.Polyline(points, {
                     fill: '',
                     stroke: 'red',
                     strokeWidth: 1,
                     selectable: false,
                     evented: false
                 });
                 
                 group.addWithUpdate(newPolyline);
             }
             
             // Update the group
             group.setCoords();
             canvas.requestRenderAll();
             updateInfoPanel();
             
            // Remove from current image filenames
            currentImageFilenames = currentImageFilenames.filter(filename => {
                const frameMatch = filename.match(/frame_(\d+)/);
                return !frameMatch || frameMatch[1] !== frameNumber;
            });
            
            // Efficiently remove just the thumbnail from the image strip
            removeThumbnailFromStrip(frameNumber);
             
             console.log(`Successfully removed frame ${frameNumber}. ${currentImageFilenames.length} images remaining.`);
         }
        
        // Function to remove a range of images from a group
        function removeImageRangeFromGroup(group, startFrame, endFrame) {
            if (!group || group.type !== 'group') {
                console.log('Cannot modify: not a group');
                return;
            }
            
            const objects = group._objects || group.objects;
            if (!objects || objects.length === 0) {
                console.log('Cannot modify: group has no objects');
                return;
            }
            
            console.log(`Searching for images ${startFrame} to ${endFrame} in group with ${objects.length} objects`);
            
            // Convert frame numbers to integers for comparison
            const startNum = parseInt(startFrame);
            const endNum = parseInt(endFrame);
            
            // Find all circles that match the frame range
            const indicesToRemove = [];
            objects.forEach((obj, index) => {
                if (obj.type === 'circle' && obj.title) {
                    // Extract frame number from title (e.g., "frame_0204" -> 204)
                    const frameMatch = obj.title.match(/frame_(\d+)/);
                    if (frameMatch) {
                        const frameNum = parseInt(frameMatch[1]);
                        if (frameNum >= startNum && frameNum <= endNum) {
                            indicesToRemove.push(index);
                            console.log(`Found frame ${frameMatch[1]} at index ${index}: ${obj.title}`);
                        }
                    }
                }
            });
            
            if (indicesToRemove.length === 0) {
                console.log(`No images found in range ${startFrame}-${endFrame}`);
                return;
            }
            
            console.log(`Removing ${indicesToRemove.length} camera positions in range ${startFrame}-${endFrame}`);
            
            // First, remove all polylines
            const polylineIndices = [];
            objects.forEach((obj, index) => {
                if (obj.type === 'polyline') {
                    polylineIndices.push(index);
                }
            });
            
            console.log(`Removing ${polylineIndices.length} existing polylines`);
            polylineIndices.sort((a, b) => b - a).forEach(index => {
                const obj = objects[index];
                console.log(`Removing polyline at index ${index}`);
                group.removeWithUpdate(obj);
            });
            
            // Remove the camera position circles
            indicesToRemove.sort((a, b) => b - a).forEach(index => {
                const obj = objects[index];
                console.log(`Removing camera position at index ${index}: ${obj.type} - ${obj.title}`);
                group.removeWithUpdate(obj);
            });
            
            // Now recreate polylines for remaining camera positions
            const remainingObjects = group._objects || group.objects;
            const remainingCircles = remainingObjects.filter(obj => obj.type === 'circle');
            
            if (remainingCircles.length > 1) {
                console.log(`Creating new polyline for ${remainingCircles.length} remaining camera positions`);
                
                // Get positions of remaining circles - add group position to circle position
                const groupLeft = group.left || 0;
                const groupTop = group.top || 0;
                console.log('Group position:', { left: groupLeft, top: groupTop });
                
                const points = remainingCircles.map((circle, index) => {
                    // Circle position relative to group + group position = absolute position
                    const pos = {
                        x: (circle.left || 0) + groupLeft,
                        y: (circle.top || 0) + groupTop
                    };
                    console.log(`Circle ${index + 1} position:`, pos, 'circle relative:', { left: circle.left, top: circle.top });
                    return pos;
                });
                
                console.log('All polyline points:', points);
                
                // Create new polyline connecting all remaining positions
                const newPolyline = new fabric.Polyline(points, {
                    fill: '',
                    stroke: 'red',
                    strokeWidth: 1,
                    selectable: false,
                    evented: false
                });
                
                group.addWithUpdate(newPolyline);
                console.log(`Added new polyline with ${points.length} points`);
            }
            
            // Update the group
            group.setCoords();
            canvas.requestRenderAll();
            updateInfoPanel();
            
            console.log(`Successfully removed ${indicesToRemove.length} objects. Group now has ${group._objects.length} objects`);
        }

        // Function to extract image filenames from SVG circles
        function extractImageFilenamesFromSVG(svgObject) {
            const imageFilenames = [];
            
            // Get the SVG element from the Fabric object
            const svgElement = svgObject._objects || svgObject.objects;
            
            if (svgElement) {
                // Look for circles in the SVG
                svgElement.forEach(obj => {
                    if (obj.type === 'circle' && obj.title) {
                        // Extract image filename from the title attribute
                        const titleMatch = obj.title.match(/Image: ([^|]+)/);
                        if (titleMatch) {
                            const imageName = titleMatch[1].trim();
                            imageFilenames.push(imageName);
                        }
                    }
                });
            }
            
            // Log all image filenames
            console.log('=== IMAGE FILENAMES IN ' + svgObject.customName + ' ===');
            imageFilenames.forEach((filename, index) => {
                console.log(`${index + 1}. ${filename}`);
            });
            console.log(`Total images: ${imageFilenames.length}`);
            console.log('==========================================');
            
            return imageFilenames;
        }


        // Initialize Fabric canvas (make it global for pan handlers)
        window.canvas = new fabric.Canvas('canvas', {
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: '#2a2a2a',
            selection: false,
            preserveObjectStacking: true
        });
        
        // Local reference for convenience
        const canvas = window.canvas;
        
        // Context menu functions
        function showContextMenu(x, y, target) {
            const menu = document.getElementById('context-menu');
            
            // Update lock/unlock state
            const lockItem = menu.querySelector('[data-action="lock"]');
            const unlockItem = menu.querySelector('[data-action="unlock"]');
            
            if (target.lockMovementX && target.lockMovementY) {
                lockItem.style.display = 'none';
                unlockItem.style.display = 'block';
            } else {
                lockItem.style.display = 'block';
                unlockItem.style.display = 'none';
            }
            
            // Show/hide "Show Images" option based on object type
            const showImagesItem = menu.querySelector('[data-action="show-images"]');
            if (target.customName && target.customName.includes('Camera Positions')) {
                showImagesItem.style.display = 'block';
            } else {
                showImagesItem.style.display = 'none';
            }
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }
        
        // Coordinate conversion functions
        function canvasToMtEden(canvasX, canvasY, mtEdenBounds, canvasWidth, canvasHeight) {
            // Find min/max Mt Eden coordinates to establish a bounding box
            const minMtEdenX = Math.min(...mtEdenBounds.map(b => b.x));
            const maxMtEdenX = Math.max(...mtEdenBounds.map(b => b.x));
            const minMtEdenY = Math.min(...mtEdenBounds.map(b => b.y));
            const maxMtEdenY = Math.max(...mtEdenBounds.map(b => b.y));

            const mtEdenWidth = maxMtEdenX - minMtEdenX;
            const mtEdenHeight = maxMtEdenY - minMtEdenY;

            // Calculate scale to fit within 80% of canvas
            const padding = 0.1; // 10% padding on each side
            const scaleX = (canvasWidth * (1 - 2 * padding)) / mtEdenWidth;
            const scaleY = (canvasHeight * (1 - 2 * padding)) / mtEdenHeight;
            const scale = Math.min(scaleX, scaleY);

            // Convert canvas coordinates to Mt Eden coordinates
            const mtEdenX = (canvasX - (canvasWidth - mtEdenWidth * scale) / 2) / scale + minMtEdenX;
            const mtEdenY = maxMtEdenY - (canvasY - (canvasHeight - mtEdenHeight * scale) / 2) / scale;

            return { x: mtEdenX, y: mtEdenY };
        }
        
        function mtEdenToCanvas(mtEdenX, mtEdenY, mtEdenBounds, canvasWidth, canvasHeight) {
            // Find min/max Mt Eden coordinates to establish a bounding box
            const minMtEdenX = Math.min(...mtEdenBounds.map(b => b.x));
            const maxMtEdenX = Math.max(...mtEdenBounds.map(b => b.x));
            const minMtEdenY = Math.min(...mtEdenBounds.map(b => b.y));
            const maxMtEdenY = Math.max(...mtEdenBounds.map(b => b.y));

            const mtEdenWidth = maxMtEdenX - minMtEdenX;
            const mtEdenHeight = maxMtEdenY - minMtEdenY;

            // Calculate scale to fit within 80% of canvas
            const padding = 0.1; // 10% padding on each side
            const scaleX = (canvasWidth * (1 - 2 * padding)) / mtEdenWidth;
            const scaleY = (canvasHeight * (1 - 2 * padding)) / mtEdenHeight;
            const scale = Math.min(scaleX, scaleY);

            // Convert Mt Eden coordinates to canvas pixels
            const canvasX = (mtEdenX - minMtEdenX) * scale + (canvasWidth - mtEdenWidth * scale) / 2;
            const canvasY = (maxMtEdenY - mtEdenY) * scale + (canvasHeight - mtEdenHeight * scale) / 2; // Flip Y axis

            return { x: canvasX, y: canvasY };
        }

        // Configure Fabric corner controls (grips) to be more visible
        fabric.Object.prototype.set({
            borderColor: '#ff6600',
            cornerColor: '#ff6600',
            cornerStrokeColor: '#ff6600',
            cornerSize: 12,
            cornerStyle: 'circle',
            transparentCorners: false,
            borderScaleFactor: 2,
            padding: 10,
            cornerStrokeWidth: 2
        });

        // Customize rotation control (make it more visible)
        fabric.Object.prototype.controls.mtr.offsetY = -40;
        fabric.Object.prototype.controls.mtr.cornerColor = '#ff6600';
        fabric.Object.prototype.controls.mtr.cornerStrokeColor = '#ffffff';
        fabric.Object.prototype.controls.mtr.cornerSize = 12;

        // Geolocation data from React Fiber extraction
        const geolocationData = {
            groundFloor: {
                image: 'floorplan_images/GroundFloor.png',
                bounds: [
                    [174.74069378281493, -36.80542933064474],   // Top-Left
                    [174.7412528239626, -36.805448062383675],   // Top-Right
                    [174.74123108024065, -36.80581545281087],   // Bottom-Right
                    [174.74067203909297, -36.80579672107194]    // Bottom-Left
                ]
            },
            firstFloor: {
                image: 'floorplan_images/FirstFloor.png',
                bounds: [
                    [174.74067575711504, -36.805431462369086],   // Top-Left
                    [174.74123484878098, -36.805451153593665],   // Top-Right
                    [174.74121799992923, -36.80582960011253],    // Bottom-Right
                    [174.7406589082633, -36.80580990888795]      // Bottom-Left
                ]
            }
        };

        // Define projections using Proj4js
        proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
        proj4.defs("EPSG:2105", "+proj=tmerc +lat_0=-36.8797222222222 +lon_0=174.764166666667 +k=0.9999 +x_0=400000 +y_0=800000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        // Calculate combined bounding box for consistent canvas coordinate system
        const allBounds = [
            ...geolocationData.groundFloor.bounds,
            ...geolocationData.firstFloor.bounds
        ];
        const allMtEden = allBounds.map(coord => {
            const result = proj4("EPSG:4326", "EPSG:2105", [coord[0], coord[1]]);
            return { x: result[0], y: result[1] };
        });
        
        // Create a proper rectangular bounding box from all points
        const minX = Math.min(...allMtEden.map(p => p.x));
        const maxX = Math.max(...allMtEden.map(p => p.x));
        const minY = Math.min(...allMtEden.map(p => p.y));
        const maxY = Math.max(...allMtEden.map(p => p.y));
        
        // Global reference bounds for canvas coordinate system (rectangular bounding box)
        let mtEdenBounds = [
            { x: minX, y: maxY },  // Top-Left
            { x: maxX, y: maxY },  // Top-Right
            { x: maxX, y: minY },  // Bottom-Right
            { x: minX, y: minY }   // Bottom-Left
        ];
        
        console.log('=== COMBINED BOUNDING BOX ===');
        console.log('Min X:', minX.toFixed(3), 'Max X:', maxX.toFixed(3));
        console.log('Min Y:', minY.toFixed(3), 'Max Y:', maxY.toFixed(3));
        console.log('Width:', (maxX - minX).toFixed(3), 'Height:', (maxY - minY).toFixed(3));
        console.log('Combined mtEdenBounds:', mtEdenBounds);

        // Convert WGS84 to Mount Eden 2000 coordinates
        function wgs84ToMtEden(lng, lat) {
            const result = proj4("EPSG:4326", "EPSG:2105", [lng, lat]);
            return { x: result[0], y: result[1] };
        }

        // Convert Mount Eden 2000 to WGS84 coordinates
        function mtEdenToWGS84(x, y) {
            const result = proj4("EPSG:2105", "EPSG:4326", [x, y]);
            return { lng: result[0], lat: result[1] };
        }

        // Convert Mt Eden coordinates to canvas coordinates
        function mtEdenToCanvas(x, y, bounds, canvasWidth, canvasHeight) {
            // Find min/max coordinates
            const minX = Math.min(...bounds.map(b => b.x));
            const maxX = Math.max(...bounds.map(b => b.x));
            const minY = Math.min(...bounds.map(b => b.y));
            const maxY = Math.max(...bounds.map(b => b.y));
            
            // Calculate scale factors
            const scaleX = canvasWidth / (maxX - minX);
            const scaleY = canvasHeight / (maxY - minY);
            const scale = Math.min(scaleX, scaleY) * 0.8; // 80% of canvas
            
            // Center the rectangle
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            // Convert coordinates
            const canvasX = centerX + (x - (minX + maxX) / 2) * scale;
            const canvasY = centerY - (y - (minY + maxY) / 2) * scale; // Flip Y axis
            
            return { x: canvasX, y: canvasY };
        }

        // Convert canvas coordinates to Mt Eden coordinates
        function canvasToMtEden(canvasX, canvasY, bounds, canvasWidth, canvasHeight) {
            // Find min/max coordinates
            const minX = Math.min(...bounds.map(b => b.x));
            const maxX = Math.max(...bounds.map(b => b.x));
            const minY = Math.min(...bounds.map(b => b.y));
            const maxY = Math.max(...bounds.map(b => b.y));
            
            // Calculate scale factors
            const scaleX = canvasWidth / (maxX - minX);
            const scaleY = canvasHeight / (maxY - minY);
            const scale = Math.min(scaleX, scaleY) * 0.8; // 80% of canvas
            
            // Center the rectangle
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            // Convert coordinates
            const x = (minX + maxX) / 2 + (canvasX - centerX) / scale;
            const y = (minY + maxY) / 2 - (canvasY - centerY) / scale; // Flip Y axis
            
            return { x: x, y: y };
        }


        // Load floorplan image with its specific bounds
        function loadFloorplanImage(imageUrl, bounds, floorName) {
            // Convert WGS84 bounds to Mt Eden coordinates (floor-specific)
            const floorMtEdenBounds = bounds.map(coord => 
                wgs84ToMtEden(coord[0], coord[1])
            );
            
            console.log('=== LOADING', floorName, '===');
            console.log('Floor Mt Eden TL:', floorMtEdenBounds[0]);
            console.log('Floor Mt Eden TR:', floorMtEdenBounds[1]);
            console.log('Floor Mt Eden BR:', floorMtEdenBounds[2]);
            console.log('Floor Mt Eden BL:', floorMtEdenBounds[3]);
            
            fabric.Image.fromURL(imageUrl, function(img) {
                // Convert Mt Eden bounds to canvas coordinates using GLOBAL reference
                const canvasBounds = floorMtEdenBounds.map(bound => 
                    mtEdenToCanvas(bound.x, bound.y, mtEdenBounds, canvas.width, canvas.height)
                );
                
                console.log(floorName, 'canvas bounds:', canvasBounds);


                // Calculate width and height from actual polygon edges
                // Top edge: distance from TL to TR
                const topWidth = Math.sqrt(
                    Math.pow(canvasBounds[1].x - canvasBounds[0].x, 2) + 
                    Math.pow(canvasBounds[1].y - canvasBounds[0].y, 2)
                );
                
                // Left edge: distance from TL to BL
                const leftHeight = Math.sqrt(
                    Math.pow(canvasBounds[3].x - canvasBounds[0].x, 2) + 
                    Math.pow(canvasBounds[3].y - canvasBounds[0].y, 2)
                );

                // Calculate rotation from the top edge (TL to TR)
                const dx = canvasBounds[1].x - canvasBounds[0].x;
                const dy = canvasBounds[1].y - canvasBounds[0].y;
                const rotationAngle = Math.atan2(dy, dx) * 180 / Math.PI;

                // Position the image at the top-left corner
                img.set({
                    left: canvasBounds[0].x,
                    top: canvasBounds[0].y,
                    scaleX: topWidth / img.width,
                    scaleY: leftHeight / img.height,
                    angle: rotationAngle,
                    originX: 'left',
                    originY: 'top',
                    selectable: true,
                    customName: 'Floorplan Image'
                });

                // Add image to canvas
                canvas.add(img);
                
                // Lock the image by default
                lockObject(img);

                console.log('Image transformation:', {
                    topWidth: topWidth,
                    leftHeight: leftHeight,
                    rotationAngle: rotationAngle,
                    topLeft: canvasBounds[0],
                    topRight: canvasBounds[1],
                    bottomRight: canvasBounds[2],
                    bottomLeft: canvasBounds[3]
                });

                updateInfoPanel();
            });
        }

        // Lock object function
        function lockObject(obj) {
            obj.lockMovementX = true;
            obj.lockMovementY = true;
            obj.lockRotation = true;
            obj.lockScalingX = true;
            obj.lockScalingY = true;
            obj.selectable = true; // Keep selectable
            obj.hasControls = false;
            obj.hasBorders = false;
            obj.set('borderColor', '#666');
            canvas.requestRenderAll();
            updateInfoPanel();
        }
        
        // Unlock object function
        function unlockObject(obj) {
            obj.lockMovementX = false;
            obj.lockMovementY = false;
            obj.lockRotation = false;
            obj.lockScalingX = false;
            obj.lockScalingY = false;
            obj.hasControls = true;
            obj.hasBorders = true;
            obj.set('borderColor', '#0096ff');
            canvas.requestRenderAll();
            updateInfoPanel();
        }

        // Load SVG function
        function loadSVG(url, svgName) {
            // Use configuration system for resource loading
            const resourceUrl = config.getResourceUrl(url);
            
            // First fetch the raw SVG to modify it
            fetch(resourceUrl)
                .then(response => response.text())
                .then(svgText => {
                    // Parse the SVG and remove viewBox restrictions
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');
                    
                    if (svgElement) {
                        // Remove viewBox to prevent clipping
                        svgElement.removeAttribute('viewBox');
                        svgElement.removeAttribute('width');
                        svgElement.removeAttribute('height');
                        
                        // Set overflow visible to show all content
                        svgElement.setAttribute('overflow', 'visible');
                        
                        // Get the modified SVG text
                        const modifiedSvgText = new XMLSerializer().serializeToString(svgElement);
                        
                        // Now load it with Fabric
                        fabric.loadSVGFromString(modifiedSvgText, function(objects, options) {
                            const svg = fabric.util.groupSVGElements(objects, options);
                            
                            // Extract title data from raw SVG and attach to circles
                            const parser = new DOMParser();
                            const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                            const circles = svgDoc.querySelectorAll('circle');
                            
                            // Match circles in Fabric objects with circles in SVG DOM
                            if (svg._objects) {
                                const fabricCircles = svg._objects.filter(obj => obj.type === 'circle');
                                fabricCircles.forEach((fabricCircle, index) => {
                                    if (circles[index]) {
                                        const titleElement = circles[index].querySelector('title');
                                        if (titleElement) {
                                            fabricCircle.title = titleElement.textContent;
                                        }
                                    }
                                });
                            }
                            
                            // Ensure no clipping
                            svg.set({
                                clipPath: null,
                                clipTo: null
                            });
                            
                            // Get floorplan size for reference
                            const floorplan = canvas.getObjects().find(obj => obj.customName === 'Floorplan Image');
                            let targetScale = 1;
                            
                            if (floorplan) {
                                // Calculate scale to make SVG 70% of floorplan size
                                const floorplanWidth = floorplan.width * floorplan.scaleX;
                                const floorplanHeight = floorplan.height * floorplan.scaleY;
                                const minDimension = Math.min(floorplanWidth, floorplanHeight) * 0.7;
                                
                                const svgMaxDimension = Math.max(svg.width, svg.height);
                                targetScale = minDimension / svgMaxDimension;
                            }
                            
                            svg.set({
                                left: 0,
                                top: 0,
                                scaleX: targetScale,
                                scaleY: targetScale,
                                originX: 'center',
                                originY: 'center',
                                customName: svgName || 'SVG',
                                selectable: true,
                                hasControls: true,
                                hasBorders: true,
                                borderColor: '#ff6600',
                                cornerColor: '#ff6600',
                                cornerSize: 12,
                                cornerStyle: 'circle',
                                transparentCorners: false,
                                cornerStrokeColor: '#ffffff',
                                cornerStrokeWidth: 2,
                                borderScaleFactor: 2
                            });
                            
                            console.log('SVG loaded (viewBox removed):', {
                                width: svg.width,
                                height: svg.height,
                                scale: targetScale,
                                objects: objects.length
                            });
                            
                            canvas.add(svg);
                            canvas.centerObject(svg);
                            canvas.setActiveObject(svg);
                            canvas.requestRenderAll();
                            updateInfoPanel();
                        });
                    }
                })
                .catch(error => {
                    console.error('Failed to load SVG:', error);
                });
        }

        // Lock/unlock functions
        function lockObject(obj) {
            obj.lockMovementX = true;
            obj.lockMovementY = true;
            obj.lockRotation = true;
            obj.lockScalingX = true;
            obj.lockScalingY = true;
            obj.selectable = true; // Keep selectable
            obj.hasControls = false;
            obj.hasBorders = false;
            obj.set('borderColor', '#666');
            canvas.requestRenderAll();
            updateInfoPanel();
        }
        
        function unlockObject(obj) {
            obj.lockMovementX = false;
            obj.lockMovementY = false;
            obj.lockRotation = false;
            obj.lockScalingX = false;
            obj.lockScalingY = false;
            obj.hasControls = true;
            obj.hasBorders = true;
            obj.set('borderColor', '#ff6600');
            canvas.requestRenderAll();
            updateInfoPanel();
        }
        

        // Update info panel
        function updateInfoPanel() {
            const zoom = canvas.getZoom();
            const vpt = canvas.viewportTransform;
            
            document.getElementById('zoom-value').textContent = Math.round(zoom * 100) + '%';
            document.getElementById('pan-value').textContent = `(${Math.round(vpt[4])}, ${Math.round(vpt[5])})`;
            
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                const name = activeObject.customName || 'Object';
                const locked = activeObject.lockMovementX ? ' [LOCKED]' : '';
                document.getElementById('selected-value').textContent = name + locked;
                
                // Debug info removed for cleaner console
                
                // Show position in Mt Eden Circuit coordinates if model space is active
                if (mtEdenBounds && mtEdenBounds.length > 0) {
                    const mtEdenCoords = canvasToMtEden(activeObject.left, activeObject.top, mtEdenBounds, canvas.width, canvas.height);
                    document.getElementById('position-value').textContent = 
                        `E: ${mtEdenCoords.x.toFixed(2)}m, N: ${mtEdenCoords.y.toFixed(2)}m`;
                } else {
                    document.getElementById('position-value').textContent = 
                        `(${Math.round(activeObject.left)}, ${Math.round(activeObject.top)})`;
                }
                
                document.getElementById('scale-value').textContent = 
                    `(${activeObject.scaleX.toFixed(2)}, ${activeObject.scaleY.toFixed(2)})`;
                document.getElementById('rotation-value').textContent = 
                    Math.round(activeObject.angle) + '°';
                document.getElementById('locked-value').textContent = 
                    activeObject.lockMovementX ? 'Yes' : 'No';
            } else {
                document.getElementById('selected-value').textContent = 'None';
                document.getElementById('position-value').textContent = '-';
                document.getElementById('scale-value').textContent = '-';
                document.getElementById('rotation-value').textContent = '-';
                document.getElementById('locked-value').textContent = '-';
                console.log('=== NO SELECTION ===');
            }
            
            // Update configuration display
            document.getElementById('mode-value').textContent = 
                window.runningFromDevelopersLocal ? 'Local Dev' : 'Production';
            document.getElementById('resource-value').textContent = 
                window.runningFromDevelopersLocal ? 'Local Files' : 'AsBuiltVault';
        }

        // Selection handling
        canvas.on('selection:created', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('selection:updated', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('selection:cleared', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:modified', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:moving', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:scaling', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:rotating', function(e) {
            updateInfoPanel();
        });

        // Real-time cursor coordinate display
        canvas.on('mouse:move', function(e) {
            const pointer = canvas.getPointer(e.e);
            const mtEdenCoords = canvasToMtEden(pointer.x, pointer.y, mtEdenBounds, canvas.width, canvas.height);
            
            document.getElementById('cursor-easting').textContent = mtEdenCoords.x.toFixed(2) + 'm';
            document.getElementById('cursor-northing').textContent = mtEdenCoords.y.toFixed(2) + 'm';
            document.getElementById('cursor-coords').style.display = 'block';
        });

        // Hide cursor coordinates when mouse leaves canvas
        canvas.on('mouse:out', function(e) {
            document.getElementById('cursor-coords').style.display = 'none';
        });
        
        // Context menu actions
        document.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const action = e.target.getAttribute('data-action');
                
                if (contextMenuTarget) {
                    switch(action) {
                        case 'lock':
                            lockObject(contextMenuTarget);
                            break;
                        case 'unlock':
                            unlockObject(contextMenuTarget);
                            break;
                        case 'bring-forward':
                            canvas.bringForward(contextMenuTarget);
                            break;
                        case 'send-backward':
                            canvas.sendBackwards(contextMenuTarget);
                            break;
                        case 'bring-to-front':
                            canvas.bringToFront(contextMenuTarget);
                            break;
                        case 'send-to-back':
                            canvas.sendToBack(contextMenuTarget);
                            break;
                        case 'show-images':
                            if (contextMenuTarget && contextMenuTarget.customName && contextMenuTarget.customName.includes('Camera Positions')) {
                                console.log('=== SHOWING IMAGES FROM: ' + contextMenuTarget.customName + ' ===');
                                const imageFilenames = extractImageFilenamesFromSVG(contextMenuTarget);
                                showImageStrip(imageFilenames);
                            } else {
                                console.log('This object is not a camera positions SVG');
                                console.log('Available objects on canvas:');
                                canvas.getObjects().forEach((obj, index) => {
                                    console.log(`${index}: ${obj.customName || 'unnamed'} (${obj.type})`);
                                });
                            }
                            break;
                        case 'remove-range':
                            if (contextMenuTarget && contextMenuTarget.type === 'group') {
                                console.log('=== REMOVING RANGE 0203-0209 FROM GROUP: ' + contextMenuTarget.customName + ' ===');
                                removeImageRangeFromGroup(contextMenuTarget, '0203', '0209');
                            } else {
                                console.log('This object is not a group that can be modified');
                            }
                            break;
                        case 'delete':
                            canvas.remove(contextMenuTarget);
                            canvas.discardActiveObject();
                            updateInfoPanel();
                            break;
                    }
                    canvas.requestRenderAll();
                }
                
                hideContextMenu();
            });
        });

        // Click handler for coordinate display
        canvas.on('mouse:down', function(e) {
            const pointer = canvas.getPointer(e.e);
            const mtEdenCoords = canvasToMtEden(pointer.x, pointer.y, mtEdenBounds, canvas.width, canvas.height);
            const wgs84Coords = mtEdenToWGS84(mtEdenCoords.x, mtEdenCoords.y);
            
            // Check if we clicked on a camera position circle
            const target = e.target;
            if (target && target.type === 'circle' && target.title && target.title.includes('Camera')) {
                // Extract coordinates from the circle's title metadata
                const titleParts = target.title.split(' | ');
                const coords2D = titleParts[1]; // "2D: (-7.68, 5.43)"
                const coords3D = titleParts[2]; // "3D: (-2.36, -3.52, -3.75)"
                
                console.log('🎯 CLICKED CAMERA DOT:', {
                    camera: titleParts[0], // "Camera 1"
                    coords2D: coords2D,
                    coords3D: coords3D,
                    clickPosition: {
                        pixel: { x: pointer.x, y: pointer.y },
                        mtEden: { x: mtEdenCoords.x, y: mtEdenCoords.y },
                        wgs84: { lng: wgs84Coords.lng, lat: wgs84Coords.lat }
                    }
                });
            } else {
                console.log('📍 CANVAS CLICK:', {
                    pixel: { x: pointer.x, y: pointer.y },
                    mtEden: { x: mtEdenCoords.x, y: mtEdenCoords.y },
                    wgs84: { lng: wgs84Coords.lng, lat: wgs84Coords.lat }
                });
            }
            
        });

        // Right-click handler for context menu
        canvas.on('mouse:down', function(e) {
            if (e.e.button === 2) { // Right click
                const clickedObject = canvas.findTarget(e.e, false);
                console.log('Right-click detected on:', clickedObject);
                console.log('Object custom name:', clickedObject ? clickedObject.customName : 'undefined');
                if (clickedObject) {
                    e.e.preventDefault();
                    showContextMenu(e.e.clientX, e.e.clientY, clickedObject);
                } else {
                    console.log('Right-clicked on empty space');
                }
            }
        });

        // Zoom functionality
        canvas.on('mouse:wheel', function(opt) {
            const evt = opt.e;
            const delta = evt.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            
            canvas.zoomToPoint({ x: evt.offsetX, y: evt.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
            updateInfoPanel();
        });

        // Selection handling
        canvas.on('selection:created', function(e) {
            updateInfoPanel();
        });

        canvas.on('selection:updated', function(e) {
            updateInfoPanel();
        });

        canvas.on('selection:cleared', function(e) {
            updateInfoPanel();
        });

        canvas.on('object:modified', function(e) {
            updateInfoPanel();
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.setWidth(window.innerWidth);
            canvas.setHeight(window.innerHeight);
            canvas.requestRenderAll();
        });

        // Initialize
        updateInfoPanel();
        
        // Load both floors
        loadFloorplanImage(geolocationData.groundFloor.image, geolocationData.groundFloor.bounds, 'Ground Floor');
        loadFloorplanImage(geolocationData.firstFloor.image, geolocationData.firstFloor.bounds, 'First Floor');
        
        console.log('=== BOTH FLOORS LOADED ===');
        console.log('Ground Floor and First Floor loaded with their respective coordinates');
        
        // Load all SVG files after a short delay (let floorplans load first)
        setTimeout(() => {
            const svgFiles = [
                'svg_files/camera_positions_0.svg',
                'svg_files/camera_positions_1.svg',
                'svg_files/camera_positions_2.svg',
                'svg_files/camera_positions_3.svg',
                'svg_files/camera_positions_4.svg',
                'svg_files/camera_positions_5.svg',
                'svg_files/camera_positions_6.svg'
            ];
            
            svgFiles.forEach((svgFile, index) => {
                loadSVG(svgFile, `Camera Positions ${index} (Enhanced)`);
            });
            
            console.log('=== ALL ENHANCED SVGs LOADED ===');
            console.log('Loaded', svgFiles.length, 'enhanced SVG files with rich metadata');
            console.log('Hover over red dots to see detailed camera information!');
        }, 1000);

    </script>
</body>
</html>
