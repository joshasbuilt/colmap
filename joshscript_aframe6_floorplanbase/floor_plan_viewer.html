<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floorplan Coordinates - Rectangle View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            overflow: hidden;
            height: 100vh;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
        }
        
        #canvas {
            display: block;
        }
        
        /* Context Menu */
        #context-menu {
            position: fixed;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 0;
            display: none;
            z-index: 10000;
            min-width: 180px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .context-menu-item {
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .context-menu-item:hover {
            background: rgba(0, 150, 255, 0.3);
        }
        
        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        
        .context-menu-separator {
            height: 1px;
            background: #444;
            margin: 4px 0;
        }
        
        /* Info Panel */
        #info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 5000;
            min-width: 300px;
        }
        
        .info-row {
            margin: 5px 0;
        }
        
        .info-label {
            display: inline-block;
            width: 100px;
            color: #999;
        }
        
        .info-value {
            color: #0f0;
            font-family: monospace;
        }
        
        .info-separator {
            height: 1px;
            background: #333;
            margin: 10px 0;
        }
        
        /* Cursor Coordinates Display */
        #cursor-coords {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            border-radius: 5px;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-menu-item" data-action="lock">Lock</div>
        <div class="context-menu-item" data-action="unlock">Unlock</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="bring-forward">Bring Forward</div>
        <div class="context-menu-item" data-action="send-backward">Send Backward</div>
        <div class="context-menu-item" data-action="bring-to-front">Bring to Front</div>
        <div class="context-menu-item" data-action="send-to-back">Send to Back</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="extract-images">Extract Image Filenames</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="delete">Delete</div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <div class="info-row">
            <span class="info-label">Zoom:</span>
            <span class="info-value" id="zoom-value">100%</span>
        </div>
        <div class="info-row">
            <span class="info-label">Pan:</span>
            <span class="info-value" id="pan-value">(0, 0)</span>
        </div>
        <div class="info-separator"></div>
        <div class="info-row">
            <span class="info-label">Selected:</span>
            <span class="info-value" id="selected-value">None</span>
        </div>
        <div class="info-row">
            <span class="info-label">Position:</span>
            <span class="info-value" id="position-value">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Scale:</span>
            <span class="info-value" id="scale-value">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Rotation:</span>
            <span class="info-value" id="rotation-value">-</span>
        </div>
        <div class="info-separator"></div>
        <div class="info-row">
            <span class="info-label">Locked:</span>
            <span class="info-value" id="locked-value">-</span>
        </div>
        <div class="info-separator"></div>
        <div class="info-row">
            <span class="info-label">Mode:</span>
            <span class="info-value" id="mode-value">-</span>
        </div>
        <div class="info-row">
            <span class="info-label">Resources:</span>
            <span class="info-value" id="resource-value">-</span>
        </div>
    </div>

        <!-- Cursor Coordinates Display -->
        <div id="cursor-coords">
            <div>N: <span id="cursor-northing">-</span></div>
            <div>E: <span id="cursor-easting">-</span></div>
        </div>
    

    <script>
        /*
         * AsBuiltVault Configuration System
         * 
         * This project uses a single configuration flag to switch between local development 
         * and AsBuiltVault production resource loading:
         * 
         * Key Configuration:
         * window.runningFromDevelopersLocal = false - This single flag controls everything
         * 
         * When false (production): Resources load from https://vaultprojectswebprod.z8.web.core.windows.net
         * When true (local dev): Resources load from local files
         * 
         * AsBuiltVault URL Structure:
         * Base URL: https://vaultprojectswebprod.z8.web.core.windows.net
         * Path prefix: /aframe-vr/aligncolmap
         * Full URL: https://vaultprojectswebprod.z8.web.core.windows.net/aframe-vr/aligncolmap/
         * 
         * How it works:
         * The system dynamically loads resources based on this flag
         * Production mode fetches images, SVGs, and other assets from AsBuiltVault storage
         * Local development mode serves files from the local file system
         * This allows seamless switching between development and production environments with a single toggle
         */
        
        // AsBuiltVault Configuration
        window.runningFromDevelopersLocal = true; // Set to true for local development
        
        // Resource loading configuration
        const config = {
            baseUrl: window.runningFromDevelopersLocal ? '' : 'https://vaultprojectswebprod.z8.web.core.windows.net',
            pathPrefix: '/aframe-vr/aligncolmap',
            getResourceUrl: function(resourcePath) {
                if (window.runningFromDevelopersLocal) {
                    return resourcePath; // Local file
                } else {
                    return this.baseUrl + this.pathPrefix + '/' + resourcePath;
                }
            }
        };
        
        // State for panning
        let isPanning = false;
        let lastPosX = 0;
        let lastPosY = 0;
        let contextMenuTarget = null;
        
        // Catch middle mouse at document level (before Fabric can interfere)
        document.addEventListener('mousedown', function(evt) {
            if (evt.button === 1) { // Middle mouse
                isPanning = true;
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
                evt.preventDefault();
                evt.stopPropagation();
            } else if (evt.button === 2) { // Right mouse
                evt.preventDefault();
                evt.stopPropagation();
                
                // Check if we're over an object
                const target = window.canvas.findTarget(evt, false);
                
                if (target) {
                    contextMenuTarget = target;
                    window.canvas.setActiveObject(target);
                    showContextMenu(evt.clientX, evt.clientY, target);
                } else {
                    hideContextMenu();
                }
            }
        }, true);
        
        document.addEventListener('mousemove', function(evt) {
            if (isPanning && window.canvas) {
                const deltaX = evt.clientX - lastPosX;
                const deltaY = evt.clientY - lastPosY;
                
                // Update viewport transform
                const vpt = window.canvas.viewportTransform;
                vpt[4] += deltaX;
                vpt[5] += deltaY;
                window.canvas.requestRenderAll();
                
                lastPosX = evt.clientX;
                lastPosY = evt.clientY;
                updateInfoPanel();
                evt.preventDefault();
            }
        }, true);
        
        document.addEventListener('mouseup', function(evt) {
            if (evt.button === 1 && isPanning) {
                isPanning = false;
                evt.preventDefault();
            }
        }, true);
        
        // Prevent browser's default context menu everywhere
        document.addEventListener('contextmenu', function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
        }, true);
        
        // Hide context menu on click
        document.addEventListener('click', () => {
            hideContextMenu();
        });

        // Function to list all objects on canvas (for debugging)
        function listAllObjects() {
            console.log('=== ALL OBJECTS ON CANVAS ===');
            canvas.getObjects().forEach((obj, index) => {
                console.log(`${index}: ${obj.customName || 'unnamed'} (${obj.type})`);
            });
        }
        
        // Make it available globally for console debugging
        window.listAllObjects = listAllObjects;
        
        // Function to extract images from any SVG by name (for testing)
        function extractImagesFromSVGByName(svgName) {
            const svgObject = canvas.getObjects().find(obj => obj.customName === svgName);
            if (svgObject) {
                console.log('Found SVG:', svgName);
                extractImageFilenamesFromSVG(svgObject);
            } else {
                console.log('SVG not found:', svgName);
                console.log('Available SVGs:');
                canvas.getObjects().forEach(obj => {
                    if (obj.customName && obj.customName.includes('Camera Positions')) {
                        console.log('- ' + obj.customName);
                    }
                });
            }
        }
        
        // Make it available globally for console debugging
        window.extractImagesFromSVGByName = extractImagesFromSVGByName;

        // Function to extract image filenames from SVG circles
        function extractImageFilenamesFromSVG(svgObject) {
            const imageFilenames = [];
            
            // Get the SVG element from the Fabric object
            const svgElement = svgObject._objects || svgObject.objects;
            
            if (svgElement) {
                // Look for circles in the SVG
                svgElement.forEach(obj => {
                    if (obj.type === 'circle' && obj.title) {
                        // Extract image filename from the title attribute
                        const titleMatch = obj.title.match(/Image: ([^|]+)/);
                        if (titleMatch) {
                            const imageName = titleMatch[1].trim();
                            imageFilenames.push(imageName);
                        }
                    }
                });
            }
            
            // Log all image filenames
            console.log('Image filenames in this SVG:');
            imageFilenames.forEach((filename, index) => {
                console.log(`${index + 1}. ${filename}`);
            });
            console.log(`Total images: ${imageFilenames.length}`);
            
            return imageFilenames;
        }

        // Initialize Fabric canvas (make it global for pan handlers)
        window.canvas = new fabric.Canvas('canvas', {
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: '#2a2a2a',
            selection: false,
            preserveObjectStacking: true
        });
        
        // Local reference for convenience
        const canvas = window.canvas;
        
        // Context menu functions
        function showContextMenu(x, y, target) {
            const menu = document.getElementById('context-menu');
            
            // Update lock/unlock state
            const lockItem = menu.querySelector('[data-action="lock"]');
            const unlockItem = menu.querySelector('[data-action="unlock"]');
            
            if (target.lockMovementX && target.lockMovementY) {
                lockItem.style.display = 'none';
                unlockItem.style.display = 'block';
            } else {
                lockItem.style.display = 'block';
                unlockItem.style.display = 'none';
            }
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }
        
        // Coordinate conversion functions
        function canvasToMtEden(canvasX, canvasY, mtEdenBounds, canvasWidth, canvasHeight) {
            // Find min/max Mt Eden coordinates to establish a bounding box
            const minMtEdenX = Math.min(...mtEdenBounds.map(b => b.x));
            const maxMtEdenX = Math.max(...mtEdenBounds.map(b => b.x));
            const minMtEdenY = Math.min(...mtEdenBounds.map(b => b.y));
            const maxMtEdenY = Math.max(...mtEdenBounds.map(b => b.y));

            const mtEdenWidth = maxMtEdenX - minMtEdenX;
            const mtEdenHeight = maxMtEdenY - minMtEdenY;

            // Calculate scale to fit within 80% of canvas
            const padding = 0.1; // 10% padding on each side
            const scaleX = (canvasWidth * (1 - 2 * padding)) / mtEdenWidth;
            const scaleY = (canvasHeight * (1 - 2 * padding)) / mtEdenHeight;
            const scale = Math.min(scaleX, scaleY);

            // Convert canvas coordinates to Mt Eden coordinates
            const mtEdenX = (canvasX - (canvasWidth - mtEdenWidth * scale) / 2) / scale + minMtEdenX;
            const mtEdenY = maxMtEdenY - (canvasY - (canvasHeight - mtEdenHeight * scale) / 2) / scale;

            return { x: mtEdenX, y: mtEdenY };
        }
        
        function mtEdenToCanvas(mtEdenX, mtEdenY, mtEdenBounds, canvasWidth, canvasHeight) {
            // Find min/max Mt Eden coordinates to establish a bounding box
            const minMtEdenX = Math.min(...mtEdenBounds.map(b => b.x));
            const maxMtEdenX = Math.max(...mtEdenBounds.map(b => b.x));
            const minMtEdenY = Math.min(...mtEdenBounds.map(b => b.y));
            const maxMtEdenY = Math.max(...mtEdenBounds.map(b => b.y));

            const mtEdenWidth = maxMtEdenX - minMtEdenX;
            const mtEdenHeight = maxMtEdenY - minMtEdenY;

            // Calculate scale to fit within 80% of canvas
            const padding = 0.1; // 10% padding on each side
            const scaleX = (canvasWidth * (1 - 2 * padding)) / mtEdenWidth;
            const scaleY = (canvasHeight * (1 - 2 * padding)) / mtEdenHeight;
            const scale = Math.min(scaleX, scaleY);

            // Convert Mt Eden coordinates to canvas pixels
            const canvasX = (mtEdenX - minMtEdenX) * scale + (canvasWidth - mtEdenWidth * scale) / 2;
            const canvasY = (maxMtEdenY - mtEdenY) * scale + (canvasHeight - mtEdenHeight * scale) / 2; // Flip Y axis

            return { x: canvasX, y: canvasY };
        }

        // Configure Fabric corner controls (grips) to be more visible
        fabric.Object.prototype.set({
            borderColor: '#ff6600',
            cornerColor: '#ff6600',
            cornerStrokeColor: '#ff6600',
            cornerSize: 12,
            cornerStyle: 'circle',
            transparentCorners: false,
            borderScaleFactor: 2,
            padding: 10,
            cornerStrokeWidth: 2
        });

        // Customize rotation control (make it more visible)
        fabric.Object.prototype.controls.mtr.offsetY = -40;
        fabric.Object.prototype.controls.mtr.cornerColor = '#ff6600';
        fabric.Object.prototype.controls.mtr.cornerStrokeColor = '#ffffff';
        fabric.Object.prototype.controls.mtr.cornerSize = 12;

        // Geolocation data from React Fiber extraction
        const geolocationData = {
            groundFloor: {
                image: 'floorplan_images/GroundFloor.png',
                bounds: [
                    [174.74069378281493, -36.80542933064474],   // Top-Left
                    [174.7412528239626, -36.805448062383675],   // Top-Right
                    [174.74123108024065, -36.80581545281087],   // Bottom-Right
                    [174.74067203909297, -36.80579672107194]    // Bottom-Left
                ]
            },
            firstFloor: {
                image: 'floorplan_images/FirstFloor.png',
                bounds: [
                    [174.74067575711504, -36.805431462369086],   // Top-Left
                    [174.74123484878098, -36.805451153593665],   // Top-Right
                    [174.74121799992923, -36.80582960011253],    // Bottom-Right
                    [174.7406589082633, -36.80580990888795]      // Bottom-Left
                ]
            }
        };

        // Define projections using Proj4js
        proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
        proj4.defs("EPSG:2105", "+proj=tmerc +lat_0=-36.8797222222222 +lon_0=174.764166666667 +k=0.9999 +x_0=400000 +y_0=800000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        // Calculate combined bounding box for consistent canvas coordinate system
        const allBounds = [
            ...geolocationData.groundFloor.bounds,
            ...geolocationData.firstFloor.bounds
        ];
        const allMtEden = allBounds.map(coord => {
            const result = proj4("EPSG:4326", "EPSG:2105", [coord[0], coord[1]]);
            return { x: result[0], y: result[1] };
        });
        
        // Create a proper rectangular bounding box from all points
        const minX = Math.min(...allMtEden.map(p => p.x));
        const maxX = Math.max(...allMtEden.map(p => p.x));
        const minY = Math.min(...allMtEden.map(p => p.y));
        const maxY = Math.max(...allMtEden.map(p => p.y));
        
        // Global reference bounds for canvas coordinate system (rectangular bounding box)
        let mtEdenBounds = [
            { x: minX, y: maxY },  // Top-Left
            { x: maxX, y: maxY },  // Top-Right
            { x: maxX, y: minY },  // Bottom-Right
            { x: minX, y: minY }   // Bottom-Left
        ];
        
        console.log('=== COMBINED BOUNDING BOX ===');
        console.log('Min X:', minX.toFixed(3), 'Max X:', maxX.toFixed(3));
        console.log('Min Y:', minY.toFixed(3), 'Max Y:', maxY.toFixed(3));
        console.log('Width:', (maxX - minX).toFixed(3), 'Height:', (maxY - minY).toFixed(3));
        console.log('Combined mtEdenBounds:', mtEdenBounds);

        // Convert WGS84 to Mount Eden 2000 coordinates
        function wgs84ToMtEden(lng, lat) {
            const result = proj4("EPSG:4326", "EPSG:2105", [lng, lat]);
            return { x: result[0], y: result[1] };
        }

        // Convert Mount Eden 2000 to WGS84 coordinates
        function mtEdenToWGS84(x, y) {
            const result = proj4("EPSG:2105", "EPSG:4326", [x, y]);
            return { lng: result[0], lat: result[1] };
        }

        // Convert Mt Eden coordinates to canvas coordinates
        function mtEdenToCanvas(x, y, bounds, canvasWidth, canvasHeight) {
            // Find min/max coordinates
            const minX = Math.min(...bounds.map(b => b.x));
            const maxX = Math.max(...bounds.map(b => b.x));
            const minY = Math.min(...bounds.map(b => b.y));
            const maxY = Math.max(...bounds.map(b => b.y));
            
            // Calculate scale factors
            const scaleX = canvasWidth / (maxX - minX);
            const scaleY = canvasHeight / (maxY - minY);
            const scale = Math.min(scaleX, scaleY) * 0.8; // 80% of canvas
            
            // Center the rectangle
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            // Convert coordinates
            const canvasX = centerX + (x - (minX + maxX) / 2) * scale;
            const canvasY = centerY - (y - (minY + maxY) / 2) * scale; // Flip Y axis
            
            return { x: canvasX, y: canvasY };
        }

        // Convert canvas coordinates to Mt Eden coordinates
        function canvasToMtEden(canvasX, canvasY, bounds, canvasWidth, canvasHeight) {
            // Find min/max coordinates
            const minX = Math.min(...bounds.map(b => b.x));
            const maxX = Math.max(...bounds.map(b => b.x));
            const minY = Math.min(...bounds.map(b => b.y));
            const maxY = Math.max(...bounds.map(b => b.y));
            
            // Calculate scale factors
            const scaleX = canvasWidth / (maxX - minX);
            const scaleY = canvasHeight / (maxY - minY);
            const scale = Math.min(scaleX, scaleY) * 0.8; // 80% of canvas
            
            // Center the rectangle
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            
            // Convert coordinates
            const x = (minX + maxX) / 2 + (canvasX - centerX) / scale;
            const y = (minY + maxY) / 2 - (canvasY - centerY) / scale; // Flip Y axis
            
            return { x: x, y: y };
        }


        // Load floorplan image with its specific bounds
        function loadFloorplanImage(imageUrl, bounds, floorName) {
            // Convert WGS84 bounds to Mt Eden coordinates (floor-specific)
            const floorMtEdenBounds = bounds.map(coord => 
                wgs84ToMtEden(coord[0], coord[1])
            );
            
            console.log('=== LOADING', floorName, '===');
            console.log('Floor Mt Eden TL:', floorMtEdenBounds[0]);
            console.log('Floor Mt Eden TR:', floorMtEdenBounds[1]);
            console.log('Floor Mt Eden BR:', floorMtEdenBounds[2]);
            console.log('Floor Mt Eden BL:', floorMtEdenBounds[3]);
            
            fabric.Image.fromURL(imageUrl, function(img) {
                // Convert Mt Eden bounds to canvas coordinates using GLOBAL reference
                const canvasBounds = floorMtEdenBounds.map(bound => 
                    mtEdenToCanvas(bound.x, bound.y, mtEdenBounds, canvas.width, canvas.height)
                );
                
                console.log(floorName, 'canvas bounds:', canvasBounds);


                // Calculate width and height from actual polygon edges
                // Top edge: distance from TL to TR
                const topWidth = Math.sqrt(
                    Math.pow(canvasBounds[1].x - canvasBounds[0].x, 2) + 
                    Math.pow(canvasBounds[1].y - canvasBounds[0].y, 2)
                );
                
                // Left edge: distance from TL to BL
                const leftHeight = Math.sqrt(
                    Math.pow(canvasBounds[3].x - canvasBounds[0].x, 2) + 
                    Math.pow(canvasBounds[3].y - canvasBounds[0].y, 2)
                );

                // Calculate rotation from the top edge (TL to TR)
                const dx = canvasBounds[1].x - canvasBounds[0].x;
                const dy = canvasBounds[1].y - canvasBounds[0].y;
                const rotationAngle = Math.atan2(dy, dx) * 180 / Math.PI;

                // Position the image at the top-left corner
                img.set({
                    left: canvasBounds[0].x,
                    top: canvasBounds[0].y,
                    scaleX: topWidth / img.width,
                    scaleY: leftHeight / img.height,
                    angle: rotationAngle,
                    originX: 'left',
                    originY: 'top',
                    selectable: true,
                    customName: 'Floorplan Image'
                });

                // Add image to canvas
                canvas.add(img);
                
                // Lock the image by default
                lockObject(img);

                console.log('Image transformation:', {
                    topWidth: topWidth,
                    leftHeight: leftHeight,
                    rotationAngle: rotationAngle,
                    topLeft: canvasBounds[0],
                    topRight: canvasBounds[1],
                    bottomRight: canvasBounds[2],
                    bottomLeft: canvasBounds[3]
                });

                updateInfoPanel();
            });
        }

        // Lock object function
        function lockObject(obj) {
            obj.lockMovementX = true;
            obj.lockMovementY = true;
            obj.lockRotation = true;
            obj.lockScalingX = true;
            obj.lockScalingY = true;
            obj.selectable = true; // Keep selectable
            obj.hasControls = false;
            obj.hasBorders = false;
            obj.set('borderColor', '#666');
            canvas.requestRenderAll();
            updateInfoPanel();
        }
        
        // Unlock object function
        function unlockObject(obj) {
            obj.lockMovementX = false;
            obj.lockMovementY = false;
            obj.lockRotation = false;
            obj.lockScalingX = false;
            obj.lockScalingY = false;
            obj.hasControls = true;
            obj.hasBorders = true;
            obj.set('borderColor', '#0096ff');
            canvas.requestRenderAll();
            updateInfoPanel();
        }

        // Load SVG function
        function loadSVG(url) {
            // Use configuration system for resource loading
            const resourceUrl = config.getResourceUrl(url);
            
            // First fetch the raw SVG to modify it
            fetch(resourceUrl)
                .then(response => response.text())
                .then(svgText => {
                    // Parse the SVG and remove viewBox restrictions
                    const parser = new DOMParser();
                    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                    const svgElement = svgDoc.querySelector('svg');
                    
                    if (svgElement) {
                        // Remove viewBox to prevent clipping
                        svgElement.removeAttribute('viewBox');
                        svgElement.removeAttribute('width');
                        svgElement.removeAttribute('height');
                        
                        // Set overflow visible to show all content
                        svgElement.setAttribute('overflow', 'visible');
                        
                        // Get the modified SVG text
                        const modifiedSvgText = new XMLSerializer().serializeToString(svgElement);
                        
                        // Now load it with Fabric
                        fabric.loadSVGFromString(modifiedSvgText, function(objects, options) {
                            const svg = fabric.util.groupSVGElements(objects, options);
                            
                            // Ensure no clipping
                            svg.set({
                                clipPath: null,
                                clipTo: null
                            });
                            
                            // Get floorplan size for reference
                            const floorplan = canvas.getObjects().find(obj => obj.customName === 'Floorplan Image');
                            let targetScale = 1;
                            
                            if (floorplan) {
                                // Calculate scale to make SVG 70% of floorplan size
                                const floorplanWidth = floorplan.width * floorplan.scaleX;
                                const floorplanHeight = floorplan.height * floorplan.scaleY;
                                const minDimension = Math.min(floorplanWidth, floorplanHeight) * 0.7;
                                
                                const svgMaxDimension = Math.max(svg.width, svg.height);
                                targetScale = minDimension / svgMaxDimension;
                            }
                            
                            svg.set({
                                left: 0,
                                top: 0,
                                scaleX: targetScale,
                                scaleY: targetScale,
                                originX: 'center',
                                originY: 'center',
                                customName: 'SVG',
                                selectable: true,
                                hasControls: true,
                                hasBorders: true,
                                borderColor: '#ff6600',
                                cornerColor: '#ff6600',
                                cornerSize: 12,
                                cornerStyle: 'circle',
                                transparentCorners: false,
                                cornerStrokeColor: '#ffffff',
                                cornerStrokeWidth: 2,
                                borderScaleFactor: 2
                            });
                            
                            console.log('SVG loaded (viewBox removed):', {
                                width: svg.width,
                                height: svg.height,
                                scale: targetScale,
                                objects: objects.length
                            });
                            
                            canvas.add(svg);
                            canvas.centerObject(svg);
                            canvas.setActiveObject(svg);
                            canvas.requestRenderAll();
                            updateInfoPanel();
                        });
                    }
                })
                .catch(error => {
                    console.error('Failed to load SVG:', error);
                });
        }

        // Lock/unlock functions
        function lockObject(obj) {
            obj.lockMovementX = true;
            obj.lockMovementY = true;
            obj.lockRotation = true;
            obj.lockScalingX = true;
            obj.lockScalingY = true;
            obj.selectable = true; // Keep selectable
            obj.hasControls = false;
            obj.hasBorders = false;
            obj.set('borderColor', '#666');
            canvas.requestRenderAll();
            updateInfoPanel();
        }
        
        function unlockObject(obj) {
            obj.lockMovementX = false;
            obj.lockMovementY = false;
            obj.lockRotation = false;
            obj.lockScalingX = false;
            obj.lockScalingY = false;
            obj.hasControls = true;
            obj.hasBorders = true;
            obj.set('borderColor', '#ff6600');
            canvas.requestRenderAll();
            updateInfoPanel();
        }
        

        // Update info panel
        function updateInfoPanel() {
            const zoom = canvas.getZoom();
            const vpt = canvas.viewportTransform;
            
            document.getElementById('zoom-value').textContent = Math.round(zoom * 100) + '%';
            document.getElementById('pan-value').textContent = `(${Math.round(vpt[4])}, ${Math.round(vpt[5])})`;
            
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                const name = activeObject.customName || 'Object';
                const locked = activeObject.lockMovementX ? ' [LOCKED]' : '';
                document.getElementById('selected-value').textContent = name + locked;
                
                // Console logging for current selection intelligence
                console.log('=== CURRENT SELECTION ===');
                console.log('Object Type:', activeObject.type);
                console.log('Custom Name:', activeObject.customName);
                console.log('Position:', { x: activeObject.left, y: activeObject.top });
                console.log('Scale:', { x: activeObject.scaleX, y: activeObject.scaleY });
                console.log('Rotation:', activeObject.angle);
                console.log('Locked:', {
                    movementX: activeObject.lockMovementX,
                    movementY: activeObject.lockMovementY,
                    rotation: activeObject.lockRotation,
                    scalingX: activeObject.lockScalingX,
                    scalingY: activeObject.lockScalingY
                });
                console.log('Selectable:', activeObject.selectable);
                console.log('Has Controls:', activeObject.hasControls);
                console.log('Has Borders:', activeObject.hasBorders);
                
                // If it's an SVG, show more details
                if (activeObject.type === 'group' && activeObject.customName && activeObject.customName.includes('SVG')) {
                    console.log('SVG Details:');
                    console.log('- Objects count:', activeObject._objects ? activeObject._objects.length : 'Unknown');
                    console.log('- Width:', activeObject.width);
                    console.log('- Height:', activeObject.height);
                    
                    // Check if it has circles (camera positions)
                    if (activeObject._objects) {
                        const circles = activeObject._objects.filter(obj => obj.type === 'circle');
                        console.log('- Camera position circles:', circles.length);
                        if (circles.length > 0) {
                            console.log('- First circle title:', circles[0].title || 'No title');
                        }
                    }
                }
                
                // Show position in Mt Eden Circuit coordinates if model space is active
                if (mtEdenBounds && mtEdenBounds.length > 0) {
                    const mtEdenCoords = canvasToMtEden(activeObject.left, activeObject.top, mtEdenBounds, canvas.width, canvas.height);
                    document.getElementById('position-value').textContent = 
                        `E: ${mtEdenCoords.x.toFixed(2)}m, N: ${mtEdenCoords.y.toFixed(2)}m`;
                    console.log('Mt Eden Coordinates:', mtEdenCoords);
                } else {
                    document.getElementById('position-value').textContent = 
                        `(${Math.round(activeObject.left)}, ${Math.round(activeObject.top)})`;
                }
                
                document.getElementById('scale-value').textContent = 
                    `(${activeObject.scaleX.toFixed(2)}, ${activeObject.scaleY.toFixed(2)})`;
                document.getElementById('rotation-value').textContent = 
                    Math.round(activeObject.angle) + 'Â°';
                document.getElementById('locked-value').textContent = 
                    activeObject.lockMovementX ? 'Yes' : 'No';
            } else {
                document.getElementById('selected-value').textContent = 'None';
                document.getElementById('position-value').textContent = '-';
                document.getElementById('scale-value').textContent = '-';
                document.getElementById('rotation-value').textContent = '-';
                document.getElementById('locked-value').textContent = '-';
                console.log('=== NO SELECTION ===');
            }
            
            // Update configuration display
            document.getElementById('mode-value').textContent = 
                window.runningFromDevelopersLocal ? 'Local Dev' : 'Production';
            document.getElementById('resource-value').textContent = 
                window.runningFromDevelopersLocal ? 'Local Files' : 'AsBuiltVault';
        }

        // Selection handling
        canvas.on('selection:created', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('selection:updated', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('selection:cleared', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:modified', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:moving', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:scaling', function(e) {
            updateInfoPanel();
        });
        
        canvas.on('object:rotating', function(e) {
            updateInfoPanel();
        });

        // Real-time cursor coordinate display
        canvas.on('mouse:move', function(e) {
            const pointer = canvas.getPointer(e.e);
            const mtEdenCoords = canvasToMtEden(pointer.x, pointer.y, mtEdenBounds, canvas.width, canvas.height);
            
            document.getElementById('cursor-easting').textContent = mtEdenCoords.x.toFixed(2) + 'm';
            document.getElementById('cursor-northing').textContent = mtEdenCoords.y.toFixed(2) + 'm';
            document.getElementById('cursor-coords').style.display = 'block';
        });

        // Hide cursor coordinates when mouse leaves canvas
        canvas.on('mouse:out', function(e) {
            document.getElementById('cursor-coords').style.display = 'none';
        });
        
        // Context menu actions
        document.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const action = e.target.getAttribute('data-action');
                
                if (contextMenuTarget) {
                    switch(action) {
                        case 'lock':
                            lockObject(contextMenuTarget);
                            break;
                        case 'unlock':
                            unlockObject(contextMenuTarget);
                            break;
                        case 'bring-forward':
                            canvas.bringForward(contextMenuTarget);
                            break;
                        case 'send-backward':
                            canvas.sendBackwards(contextMenuTarget);
                            break;
                        case 'bring-to-front':
                            canvas.bringToFront(contextMenuTarget);
                            break;
                        case 'send-to-back':
                            canvas.sendToBack(contextMenuTarget);
                            break;
                        case 'extract-images':
                            console.log('Context menu target:', contextMenuTarget);
                            console.log('Custom name:', contextMenuTarget ? contextMenuTarget.customName : 'undefined');
                            if (contextMenuTarget && contextMenuTarget.customName && contextMenuTarget.customName.includes('Camera Positions')) {
                                console.log('=== EXTRACTING IMAGES FROM: ' + contextMenuTarget.customName + ' ===');
                                extractImageFilenamesFromSVG(contextMenuTarget);
                            } else {
                                console.log('This object is not a camera positions SVG');
                                console.log('Available objects on canvas:');
                                canvas.getObjects().forEach((obj, index) => {
                                    console.log(`${index}: ${obj.customName || 'unnamed'} (${obj.type})`);
                                });
                            }
                            break;
                        case 'delete':
                            canvas.remove(contextMenuTarget);
                            canvas.discardActiveObject();
                            updateInfoPanel();
                            break;
                    }
                    canvas.requestRenderAll();
                }
                
                hideContextMenu();
            });
        });

        // Click handler for coordinate display
        canvas.on('mouse:down', function(e) {
            const pointer = canvas.getPointer(e.e);
            const mtEdenCoords = canvasToMtEden(pointer.x, pointer.y, mtEdenBounds, canvas.width, canvas.height);
            const wgs84Coords = mtEdenToWGS84(mtEdenCoords.x, mtEdenCoords.y);
            
            console.log('Click coordinates:', {
                pixel: { x: pointer.x, y: pointer.y },
                mtEden: { x: mtEdenCoords.x, y: mtEdenCoords.y },
                wgs84: { lng: wgs84Coords.lng, lat: wgs84Coords.lat }
            });
            
            // Check if an SVG was clicked and extract image filenames
            const clickedObject = canvas.findTarget(e.e, false);
            if (clickedObject && clickedObject.customName && clickedObject.customName.includes('Camera Positions')) {
                console.log('=== SVG CLICKED: ' + clickedObject.customName + ' ===');
                extractImageFilenamesFromSVG(clickedObject);
                
                // Enable selection temporarily and select the SVG
                canvas.selection = true;
                canvas.setActiveObject(clickedObject);
                canvas.requestRenderAll();
                
                // Disable selection again after a short delay
                setTimeout(() => {
                    canvas.selection = false;
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                }, 100);
            }
        });

        // Right-click handler for context menu
        canvas.on('mouse:down', function(e) {
            if (e.e.button === 2) { // Right click
                const clickedObject = canvas.findTarget(e.e, false);
                console.log('Right-click detected on:', clickedObject);
                console.log('Object custom name:', clickedObject ? clickedObject.customName : 'undefined');
                if (clickedObject && clickedObject.customName && clickedObject.customName.includes('Camera Positions')) {
                    e.e.preventDefault();
                    showContextMenu(e.e, clickedObject);
                } else {
                    console.log('Right-clicked object is not a camera positions SVG');
                }
            }
        });

        // Zoom functionality
        canvas.on('mouse:wheel', function(opt) {
            const evt = opt.e;
            const delta = evt.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            
            canvas.zoomToPoint({ x: evt.offsetX, y: evt.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
            updateInfoPanel();
        });

        // Selection handling
        canvas.on('selection:created', function(e) {
            updateInfoPanel();
        });

        canvas.on('selection:updated', function(e) {
            updateInfoPanel();
        });

        canvas.on('selection:cleared', function(e) {
            updateInfoPanel();
        });

        canvas.on('object:modified', function(e) {
            updateInfoPanel();
        });

        // Window resize
        window.addEventListener('resize', () => {
            canvas.setWidth(window.innerWidth);
            canvas.setHeight(window.innerHeight);
            canvas.requestRenderAll();
        });

        // Initialize
        updateInfoPanel();
        
        // Load both floors
        loadFloorplanImage(geolocationData.groundFloor.image, geolocationData.groundFloor.bounds, 'Ground Floor');
        loadFloorplanImage(geolocationData.firstFloor.image, geolocationData.firstFloor.bounds, 'First Floor');
        
        console.log('=== BOTH FLOORS LOADED ===');
        console.log('Ground Floor and First Floor loaded with their respective coordinates');
        
        // Load all SVG files after a short delay (let floorplans load first)
        setTimeout(() => {
            const svgFiles = [
                'svg_files/camera_positions_0.svg',
                'svg_files/camera_positions_1.svg',
                'svg_files/camera_positions_2.svg',
                'svg_files/camera_positions_3.svg',
                'svg_files/camera_positions_4.svg',
                'svg_files/camera_positions_5.svg',
                'svg_files/camera_positions_6.svg'
            ];
            
            svgFiles.forEach((svgFile, index) => {
                loadSVG(svgFile, `Camera Positions ${index} (Enhanced)`);
            });
            
            console.log('=== ALL ENHANCED SVGs LOADED ===');
            console.log('Loaded', svgFiles.length, 'enhanced SVG files with rich metadata');
            console.log('Hover over red dots to see detailed camera information!');
        }, 1000);

    </script>
</body>
</html>
